#!/bin/bash

#
# MIT License
#
# Copyright (c) 2021 Reiikz
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#

#######################################################################
######			---------------------------------------------         #
######							ATENTION                              #
######			---------------------------------------------         #
######		PREVIOUSLY THIS SCRIPT REQUIRED THE MODIFICATION          #
######		OF IN FILE VARIABLES, THIS HOWEVER IS NO LONGER THE CASE  #
######		PLEASE REFER TO THE HELP GIVEN WHEN RUNNING THE SCRIPT    #
######		WITH NO OPTIONS FOR MORE INFORMATION ON HOW TO CONFIGURE  #
######		YOUR STARBOUND SERVER									  #
######																  #
#######################################################################

VERSION="sid-(development version)"
COPYRIGHT_YEAR="2022"
SOURCE_URL="https://github.com/Reiikz/your-awesm"
ERROR_REPORTING_TO="https://github.com/Reiikz/your-awesm/issues"
DOCUMENTATION="https://github.com/Reiikz/your-awesm/wiki"
CONFIGVER=2

#STARBOUND APP ID, this is the Game's APP ID and it is used to download mods, do not change it
APPID=211820

# ~~~~~~~~~~~~~~~~~~~~~~~ SCRIPT STARTS HERE
#FORMATTING CODES
FC_RESET="\e[0m"
FC_BOLD="\e[1m"

#FORMATTING
FC_DEFAULT_COLOR="\e[39m"
FC_RED="\e[31m"
FC_GREEN="\e[32m"
FC_YELLOW="\e[33m"
FC_BLUE="\e[34m"
FC_MAGENTA="\e[35m"
FC_CYAN="\e[36m"
FC_LIGHT_GRAY="\e[37m"
FC_DARK_GRAY="\e[90m"
FC_LIGHT_RED="\e[91m"
FC_LIGHT_GREEN="\e[92m"
FC_LIGHT_YELLOW="\e[93m"
FC_LIGHT_BLUE="\e[94m"
FC_LIGHT_MAGENTA="\e[95m"
FC_LIGHT_CYAN="\e[96m"
FC_WHITE="\e[97m"

MY_UID="your-awesm.$(basename ${BASH_SOURCE[0]}).$$"
MYSELF="$(basename ${BASH_SOURCE[0]})"
USER_HOME="$(getent passwd $(whoami) | cut -d':' -f6)"

CONFIG_DIR="$USER_HOME/.config/RZ.star-server/$CONFIGVER"
CACHE_DIR="$USER_HOME/.cache/RZ.star-server-cache"
SERVER_WORKERS="$USER_HOME/.local/lib/RZ.star-server/1/server_workers"
mkdir -p $CONFIG_DIR
COLORFUL=1


####### Ensure we're not running over an older setup using this script
# function hfsejka8574sfhjhi {
# 	if [ ! -f "/usr/local/lib/RZ/star-server/cfgu/runConfigurationUpdate" ]; then
# 		echo "You are missing /usr/local/lib/RZ/star-server/cfgu/runConfigurationUpdate"
# 		echo "Please visit https://github.com/Reiikz/your-awesm to solve this issue"
# 		exit 1
# 	fi
# 	if [ ! -f "$CONFIG_DIR/PRERUN" ]; then
# 		/usr/local/lib/RZ/star-server/cfgu/runConfigurationUpdate "${BASH_SOURCE[0]}" ?
# 	# else
# 		# //other version check
# 	fi
# }
# if [ ! -f "$CONFIG_DIR/../VERSION" ]; then
# 	echo $VERSION > "$CONFIG_DIR/../VERSION"
# else
# 	lv="$(cat "$CONFIG_DIR/../VERSION" | sed "s/\.//g")"
# 	cv="$(sed "s/\.//g" <<< $VERSION)"
# 	if [ $lv -gt $cv ]; then
# 		echo "W: DOWNGRADE IS DANGEROUS RUNNING AN OLDER VERSION OF THIS SCRIPT ON A NEWER SETUP MIGHT CAUSE UNDEFINED BEHAVIOUR"
# 	fi
# 	if [ $lv -lt $cv ]; then
# 		hfsejka8574sfhjhi
# 	fi
# fi
if [ -f "$CONFIG_DIR/PRERUN" ]; then
	source "$CONFIG_DIR/PRERUN"
fi

source $USER_HOME/.bashrc 2>/dev/null

#DIR=$(dirname $0)
#cd $DIR

function toLower {
	echo "$1" | tr '[:upper:]' '[:lower:]'
}

function isYes {
	if [ "yes" == "$(toLower "$1")" ]; then
		return 0
	fi
	return 1
}

function saveVar {
	[ "$1" != "" ] && declare -p $1 > /dev/null 2> /dev/null || return 1
    [ "$2" == "" ] && return 2
	local dir="$2"
    mkdir -p "$dir"
    [ ! -w "$2" ] && return 3
	if [ "$(toLower $3)" != "no" ] && [ "$3" != "0" ] && [ "$(toLower $3)" != "false" ]; then
    	declare -p $1 | sed -E "s/^declare -/declare -g -/g" > "$dir/$1.bvar" 2> /dev/null
	else
		declare -p $1 > "$dir/$1.bvar" 2> /dev/null
	fi
    chmod 700 "$dir/$1.bvar"
	# echo saving var $1 to $2
	# declare -p $1
	# cat $dir/$1.bvar
}

function loadVar {
    unset "$1"
    local dir="$2"
    if ! source "$dir/$1.bvar" 2> /dev/null; then
        return 1
    else
        declare -p $1 | sed -E "s/^declare -/declare -g -/g"
        return 0
    fi
}

function isArr {
	if [ ! -z "$(grep -oE "^declare\s+-(a|A)" <<< "$(declare -p $1 2> /dev/null)")" ]; then
		return 0
	else
		return 1
	fi
}

function isAssoc {
	if [ ! -z "$(grep -oE "^declare\s+-A" <<< "$(declare -p $1 2> /dev/null)")" ]; then
		return 0
	else
		return 1
	fi
}

function isInArray {
    eval "$(echo "$1" | sed -E "s/^declare -/declare -g -/g" | sed -E "s/declare -g -a [A-Za-z0-9]+=/declare -g -a temporary=/g")"
    for x in ${temporary[@]}; do
        if [ "$2" == "$x" ]; then
            unset temporary
            return 0
        fi
    done
    unset temporary
    return 1
}

function coecho {
	local formatting=$1
	shift
	local message=""
	while [ $# -gt 0 ]; do
		[ "$message" == "" ] && message="$1" || message="$message $1"
		shift
	done
	if [ "$COLORFUL" == "1" ]; then
		echo -e "$formatting$message$FC_RESET"
	else
		echo "$message" | sed -E "s/\\\e\[[0-9]{1,2}(m)//g"
	fi
}

function linkify {
    if [ "$COPY" == "1" ]; then
        if ! cp -r "$1" "$2"; then
			coecho "$FC_RED$FC_BOLD" "could not copy: \"$1\" to \"$2\""
			return 1
		fi
    else
        if ! ln -s "$(realpath --no-symlinks "$1")" "$(realpath --no-symlinks "$2")"; then
			coecho "$FC_RED$FC_BOLD" "could not link: \"$1\" to \"$2\""
			return 1
		fi
    fi
}

function checkPermission {
	if [ -z "$SUDO_COMMAND" ] || [ "$(whoami)" == "root" ]; then
		coecho "\e[1m\e[31m" "Not allowed"
		exit 0
	fi
}

function closeIfNotProfile {
	if [ -z "$CURRENT_PROFILE" ]; then
		coecho "$FC_LIGHT_GREEN$FC_BOLD" "Current profile is not set, please change your current profile with $FC_LIGHT_CYAN$MYSELF -s <profile name> $FC_LIGHT_GREEN""or $FC_LIGHT_CYAN$MYSELF -s <profile alias>"
		exit 1
	fi
}

function killScreen {
	[ $# -ne 1 ] && echo "bad usage of waitUntil" && exit 1
	screen -X -S $(screen -ls | grep -oE "[0-9]+\.$1" | sed -e "s/\..*$//g") kill
}

function sendCommand {
	[ $# -ne 2 ] && echo "bad usage of sendCommand" && exit 1
	screen -S   $1 -p 0 -X stuff "$2^M"
}

function waitUntilRgex {
	if [ $# -ne 3 ] && [ $# -ne 4 ]; then
		echo "bad usage of waitUntil" && exit 1
	fi
	start=$(date "+%s")
	screen -S   $1 -p 0 -X hardcopy "/tmp/$1.screen"
	term=$(cat /tmp/$1.screen)
	while [ -z "$(grep -oE "$2" <<< $term)" ]; do
		screen -S   $1 -p 0 -X hardcopy "/tmp/$1.screen"
		term=$(cat /tmp/$1.screen)
		sleep 1
		[ ! -z $4 ] && echo -n "$4"
		if [ $(( $(date "+%s") - $start )) -ge $3 ]; then
			FAIL=true
			break
		fi
	done
	#rm /tmp/$1.screen
	[ ! -z $4 ] && echo ""
}

function isRegexThere {
	[ -e "/tmp/$1.screen" ] && rm -rf "/tmp/$1.screen"
	screen -S   $1 -p 0 -X hardcopy "/tmp/$1.screen"
	term=$(cat /tmp/$1.screen)
	if [ -z "$(grep -oE "$2" <<< $term)" ]; then
		return 1
	else
		return 0
	fi
}

function isLastLineRegex {
	[ -e "/tmp/$1.screen" ] && rm -rf "/tmp/$1.screen"
	screen -S   $1 -p 0 -X hardcopy "/tmp/$1.screen"
	if [ -z "$(tail -n 1 /tmp/$1.screen | grep -oE "$2")" ]; then
		return 1
	else
		return 0
	fi
}

function waitUntil {
	if [ $# -ne 3 ] && [ $# -ne 4 ]; then
		echo "bad usage of waitUntil" && exit 1
	fi
	start=$(date "+%s")
	screen -S   $1 -p 0 -X hardcopy "/tmp/$1.screen"
	term=$(cat /tmp/$1.screen)
	while [ -z "$(grep -o "$2" <<< $term)" ]; do
		screen -S   $1 -p 0 -X hardcopy "/tmp/$1.screen"
		term=$(cat /tmp/$1.screen)
		sleep 1
		[ ! -z $4 ] && echo -n "$4"
		if [ $(( $(date "+%s") - $start )) -ge $3 ]; then
			FAIL=true
			break
		fi
	done
	#rm /tmp/$1.screen
	[ ! -z $4 ] && echo ""
}

function isScreen {
	echo -n "$(screen -ls | grep -oE "[0-9]+\.$1\s{1}" | sed -e "s/\..*$//g")"
}

function printOptions {
	echo -e "\e[1m\e[32mavailable options:"
	echo -e "  start           		- start the starbound server"
	echo -e "  stop            		- stop the starbound server"
	#echo -e "  demonize        		- \e[31mdo not use\e[0m\e[32m\e[1m"
	echo "  update <workshop link>	- stop the service (if it is running), and perform mod update"
	echo "  relink <workshop link>	- adds the mods from the modpack"
	echo "  unlink          		- removes the mods from the modpack"
	echo "  reset-universe  		- resets the universe (not reverseable and will stop the server before proceeding!)"
	echo "  --boring			- removes color coding"
	echo "  --delete-workshop		- deletes workshop folder when combined with update"
	echo "  --start			- starts the server after running update"
	echo "  --stop			- stops the server if need be when running update"
	echo "  --restart			- --start and --stop combined"
	echo "  --dry-run			- runs everything as normal but steamcmd (it skips running steamcmd)"
	echo "  --cp				- runs cp instead of ln so you get the files and not symlinks"
	echo "  get-last-log			- copy the last logfile to the current directory"
	echo "  get-all-logs			- get all starbound logfiles"
	echo "  config			- edit starbound config with nano"
	echo "  sbdir				- show me to starbound's directory"
	echo -e "  hook-log        		- see the server long in real time\e[0m"
}

function cleanup {
	rm -rf /tmp/$MY_UID*
}

function findSteam {
	if [ -d "$USER_HOME/.steam/steam/steamapps" ]; then
		declare -g -- STEAM="$USER_HOME/.steam/steam/steamapps"
		return 0
	fi

	if [ -d "$USER_HOME/.steam/steam/SteamApps" ]; then
		declare -g -- STEAM="$USER_HOME/.steam/steam/SteamApps"
		return 0
	fi

	if [ -d "$USER_HOME/.steam/debian-installation/steamapps" ]; then
		declare -g -- STEAM="$USER_HOME/.steam/debian-installation/steamapps"
		return 0
	fi
	
	coecho "$FC_LIGHT_YELLOW$FC_BOLD" "Steam folder not found running 'steamcmd \"+quit\"'"
	mkdir -p ${PROFILE[DUMP_FILES]}

	/usr/games/steamcmd "+quit" 2>&1 > ${PROFILE[DUMP_FILES]}/latestSteamCMDdump.stdout

	if [ -d "$USER_HOME/.steam/steam/steamapps" ]; then
		declare -g -- STEAM="$USER_HOME/.steam/steam/steamapps"
		return 0
	fi

	if [ -d "$USER_HOME/.steam/steam/SteamApps" ]; then
		declare -g -- STEAM="$USER_HOME/.steam/steam/SteamApps"
		return 0
	fi

	if [ -d "$USER_HOME/.steam/debian-installation/steamapps" ]; then
		declare -g -- STEAM="$USER_HOME/.steam/debian-installation/steamapps"
		return 0
	fi

	coecho "$FC_LIGHT_RED$FC_BOLD" "OOPS Steam could not be found"
	exit 1
}

function getModName {
	local id="$1"
	if [ -f "$CACHE_DIR/modnames/$id.name" ]; then
		local c=0
		while [ -z "$(cat $CACHE_DIR/modnames/$id.name)" ]; do
			mkdir -p $CACHE_DIR/modnames
			echo "$(wget "https://steamcommunity.com/sharedfiles/filedetails/?id=$id" -O - 2> /dev/null | grep -oP "(?<=<div class\=(\"|\')workshopItemTitle(\"|\')>)(.*)(?=<\/div>)")" > $CACHE_DIR/modnames/$id.name
			c=$(($c+1))
			if [ $c -gt 5 ]; then
				break
			fi
		done
		echo "$(cat $CACHE_DIR/modnames/$id.name)"
	else
		mkdir -p $CACHE_DIR/modnames
		local name="$(wget "https://steamcommunity.com/sharedfiles/filedetails/?id=$id" -O - 2> /dev/null | grep -oP "(?<=<div class\=(\"|\')workshopItemTitle(\"|\')>)(.*)(?=<\/div>)")"
		echo "$name" > $CACHE_DIR/modnames/$id.name
		echo "$name"
	fi

}

function parseModpack {
	if [ -z "$(grep -oE "^(http|https)://steamcommunity.com/sharedfiles/filedetails/\?id=[0-9]+" <<< $1)" ]; then
		coecho "$FC_LIGHT_RED$FC_BOLD" "$1: is not a valid workshop link"
		exit 1
	fi
	rm -f /tmp/$MY_UID.workshop.html
	wget $1 -O /tmp/$MY_UID.workshop.html 2> /dev/null
	PARSED_MODPACK[RAW]="$(cat /tmp/$MY_UID.workshop.html)"
	PARSED_MODPACK[NAME]="$(echo "${PARSED_MODPACK[RAW]}" | grep -oE "<div\s+class=\"workshopItemTitle\">.+</div>" | head -n 1 | sed -E "s/(<div\s+class=\"workshopItemTitle\">|<\/div>)//g")"
	local items="$(echo "${PARSED_MODPACK[RAW]}" | tr -d \\n | grep -oE "<div\s+class=(\"|\')collectionItemDetails(\"|\')>\s*<a\s*href=(\"|\')http(s)*\:\/\/steamcommunity\.com\/sharedfiles\/filedetails\/\?id=[0-9]+(\"|\')\s*>")"
	[ "$items" == "" ] && return 1
	local c=0
	while read -r line; do
		local link="$(grep -oE "http(s)*\:\/\/steamcommunity\.com\/sharedfiles\/filedetails\/\?id=[0-9]+" <<< $line)"
		[ "$link" == "" ] && continue
		local id="$(grep -oE "id=[0-9]+" <<< $link | grep -oE "[0-9]+")"
		PARSED_MODPACK["$id"~link]="$link"
		PARSED_MODPACK[$c~id]="$id"
		PARSED_MODPACK[$c~link]="$link"

		if [ -f $CACHE_DIR/modnames/$id.name ]; then
			PARSED_MODPACK[$c~name]="$(cat $CACHE_DIR/modnames/$id.name)"
			PARSED_MODPACK[$id~name]="$(cat $CACHE_DIR/modnames/$id.name)"
		else
			mkdir -p $CACHE_DIR/modnames
			local name="$(wget "$link" -O - 2> /dev/null | grep -oP "(?<=<div class\=(\"|\')workshopItemTitle(\"|\')>)(.*)(?=<\/div>)")"
			echo "$name" > $CACHE_DIR/modnames/$id.name
			PARSED_MODPACK[$c~name]="$name"
			PARSED_MODPACK[$id~name]="$name"
		fi
		c=$(($c+1))
		coecho "$FC_CYAN" "Found Content: ${PARSED_MODPACK[$id~name]} ($id)"

	done <<< $items
	if [ $c -eq 0 ]; then
		PARSED_MODPACK[~modCount]="$c"
		return 2
	fi
	PARSED_MODPACK[~lastItem]="$(($c-1))"
	PARSED_MODPACK[~modCount]="$c"
	coecho "$FC_LIGHT_GREEN$FC_BOLD" "Parsed modpack '${PARSED_MODPACK[NAME]}', $c workshop items found"
	cleanup
	return 0
}

function loadMods {
	if [ "${PARSED_MODPACK[NAME]}" == "" ]; then
		unset PARSED_MODPACK
		declare -gA PARSED_MODPACK
		local pmfc=1
		while ! parseModpack "$MODPACK"; do
			coecho "$FC_LIGHT_YELLOW$FC_BOLD" "WARNING: mods couldn't be laoded attempt #$pmfc"
			unset PARSED_MODPACK
			declare -gA PARSED_MODPACK
			if [ $pmfc -gt 5 ]; then
				coecho "$FC_RED$FC_BOLD" "Could not retreive modlist after $pmfc attempts"
				return 1
			fi
			pmfc=$(($pmfc+1))
		done
	fi
	return 0
}

function downloadMod {
	closeIfNotProfile
	findSteam
	coecho "$FC_LIGHT_GREEN" "Downloading $1 \"$(getModName $1)\""
	local cmdline
	cmdline="+login anonymous +workshop_download_item $APPID $1 +quit"
	coecho "$FC_LIGHT_CYAN$FC_BOLD" "steamcmd commandline dump: $cmdline"
	coecho "$FC_LIGHT_CYAN$FC_BOLD" "dumping steamcmd output to: ${PROFILE[DUMP_FILES]}/latestSteamCMDdump.stdout"
	coecho "$FC_LIGHT_GREEN" "Running steamcmd, this might take a while depending on the modpack size..."
	mkdir -p "${PROFILE[DUMP_FILES]}"
	if [ "$DRY_RUN" == "1" ]; then
		coecho "$FC_LIGHT_YELLOW$FC_BOLD" "WARNING: Dry run, skipped steamcmd"
	else
		/usr/games/steamcmd $cmdline 2>&1 > "${PROFILE[DUMP_FILES]}/latestSteamCMDdump.stdout"
	fi
	coecho "$FC_LIGHT_GREEN" "Looking for errors in the steam dump"
	local good=0
	local errors=""
	errors="$(cat ${PROFILE[DUMP_FILES]}/latestSteamCMDdump.stdout 2>/dev/null | grep "ERROR")"
	if [ ! -z "$errors" ]; then
		return 1
	else	
		local override="$(cat "${PROFILE[DUMP_FILES]}/latestSteamCMDdump.stdout" | grep "Success" | grep -oE "\".*\"" | sed -E "s/\"//g")"
		if [ "$override" != "$STEAM/workshop/content/$APPID/$1" ] && [ -d "$override" ]; then
			coecho "$FC_YELLOW$FC_BOLD" "Expected \"$(getModName $1)\" at: ""/workshop/content/$APPID/$1"
			coecho "$FC_YELLOW$FC_BOLD" "\"$(getModName $1)\" downloaded to: $override"
			coecho "$FC_YELLOW$FC_BOLD" "WARNING: dir override set for mod id $1"
			mkdir -p "${PROFILE[PROFILE]}/diroverride"
			echo "$override" > "${PROFILE[PROFILE]}/diroverride/$1.path"
		fi
		return 0
	fi
}

function linkMods {
	closeIfNotProfile
	if ! loadMods; then
		[ -z "${PROFILE[ON_0_MODS]}" ] && coecho "$FC_RED$FCBOLD" "Variable ON_0_MODS must be set"

		case ${PROFILE[ON_0_MODS]} in

			skip)
				return 0
			;;

			crash)
				exit 1
			;;

			*)
				coecho "$FC_RED$FCBOLD" "Variable ON_0_MODS improperly set (${PROFILE[ON_0_MODS]})"
				exit 1
			;;

		esac
	fi
	local succesfullMods=0
	local succesfullModsPak=0
	local failcount=0
	if findSteam; then
		coecho "$FC_CYAN" "Steam found in: $STEAM"

		for c in $(seq 0 ${PARSED_MODPACK[~lastItem]}); do
			local id="${PARSED_MODPACK[$c~id]}"
			local name=${PARSED_MODPACK[$c~name]}

			local origin=""
			if [ -f "${PROFILE[PROFILE]}/diroverride/$id.path" ]; then
				coecho "$FC_YELLOW$FC_BOLD" "WARNING: OVERRIDE FOR MOD ($m) PATH SET IN ${PROFILE[PROFILE]}/diroverride/$m.path"
				origin="$(cat "${PROFILE[PROFILE]}/diroverride/$id.path")"
			else
				origin="$STEAM/workshop/content/$APPID/$id"
			fi

			if [ -d "$origin" ]; then
				local fn="$(ls $origin -l)"
				if [ "$fn" == "" ]; then
					coecho "$FC_LIGHT_RED$FC_BOLD" "Directory: $origin was empty"
					failcount=$(($failcount+1))
					continue
				fi
				fn="$(grep -oE "^.*(.pak)" <<< $fn)"
				fn="$(sed -E "s/^.*[0-9]{2}(:)[0-9]{2}\s{1}//g" <<< $fn )"
				filenumber=1
				coecho "$FC_LIGHT_GREEN" "Linking Mod: '$name'"
				local err=""
				while IFS= read -r af; do
					err=""
					if [ "$COPY" == "1" ]; then
						err="$(cp "$origin/$af" "${PROFILE[SERVER_WORKER]}/mods/$id-$c""_$filenumber-$af" 2>&1)"
					else
						err="$(ln -s "$origin/$af" "${PROFILE[SERVER_WORKER]}/mods/$id-$c""_$filenumber-$af" 2>&1)"
					fi
					if [ "$err" == "" ]; then
						coecho "$FC_LIGHT_GREEN$FC_BOLD" "	File: $origin/$af"
						coecho "$FC_LIGHT_GREEN$FC_BOLD" "	Linked to: ${PROFILE[SERVER_WORKER]}/mods/$id-$c""_$filenumber-$af"
						succesfullModsPak=$(($succesfullModsPak+1))
					else
						coecho "$FC_LIGHT_RED$FC_BOLD" "	could not link file $origin/$af"
						coecho "$FC_LIGHT_RED$FC_BOLD" "	Error: $err"
					fi
					filenumber=$(($filenumber+1))
				done <<< "$fn"
				if [ "$err" == "" ]; then
					succesfullMods=$(($succesfullMods+1))
				else
					failcount="$(($failcount+1))"
				fi
				echo ""
			else
				UPDATE=1
				if [ ! -z "$UPDATED" ]; then
					coecho "$FC_LIGHT_RED$FC_BOLD" "Modpack update was attempted but '$name' is missing"
					coecho "$FC_LIGHT_RED$FC_BOLD" "	ID: ${PARSED_MODPACK[$c~id]}"
					coecho "$FC_LIGHT_RED$FC_BOLD" "	assumed dir path: $origin"
					coecho "$FC_LIGHT_RED$FC_BOLD" "	workshop link: ${PARSED_MODPACK[$c~link]}"
					if [ ! -z "${RETRIED_MODS[$id]}" ]; then
						exit 1
					else
						coecho "$FC_LIGHT_YELLOW$FC_BOLD" "Will retry to download '$name'"
						local fcc=0
						while ! downloadMod $id; do
							fcc=$(($fcc+1))
							if [ $fcc -gt 5 ]; then
								coecho "$FC_BOLD$FC_RED" "Tried to download $(getModName $id) $(($fcc-1)) times, failed to update"
								exit 1
							fi
						done
						declare -p RETRIED_MODS 2>/dev/null >/dev/null || declare -gA RETRIED_MODS
						RETRIED_MODS[$id]=yes
						unlink
						linkMods
					fi
					exit 1
				else
					coecho "$FC_LIGHT_RED$FC_BOLD" "'$name' is missing, will call update"
					break
				fi
			fi

		done

		coecho "$FC_YELLOW$FC_BOLD" "Linking extra mods"
		local c="${PARSED_MODPACK[~modCount]}"
		local succesfullModsPakExtra=0
		local succesfullModsExtra=0
		local failcountExtra=0
		for m in ${EXTRA_MODS[@]}; do

			local origin=""
			if [ -e "${PROFILE[PROFILE]}/diroverride/$m.path" ]; then
				coecho "$FC_YELLOW$FC_BOLD" "WARNING: OVERRIDE FOR MOD ($m) PATH SET IN ${PROFILE[PROFILE]}/diroverride/$m.path"
				origin="$(cat "${PROFILE[PROFILE]}/diroverride/$m.path")"
			else
				origin="$STEAM/workshop/content/$APPID/$m"
			fi

			if [ -d "$origin" ]; then

				local fn="$(ls $origin -l)"
				if [ "$fn" == "" ]; then
					coecho "$FC_LIGHT_RED$FC_BOLD" "Directory: $origin was empty"
					failcount=$(($failcount+1))
					continue
				fi
				fn="$(grep -oE "^.*(.pak)" <<< $fn)"
				fn="$(sed -E "s/^.*[0-9]{2}(:)[0-9]{2}\s{1}//g" <<< $fn )"
				local filenumber=1
				coecho "$FC_LIGHT_GREEN" "Linking Mod: '$(getModName $m)'"
				local err=""
				while IFS= read -r af; do
					err=""
					if [ "$COPY" == "1" ]; then
						err="$(cp "$origin/$af" "${PROFILE[SERVER_WORKER]}/mods/$id-$c""_$filenumber-$af" 2>&1)"
					else
						err="$(ln -s "$origin/$af" "${PROFILE[SERVER_WORKER]}/mods/$id-$c""_$filenumber-$af" 2>&1)"
					fi
					if [ "$err" == "" ]; then
						coecho "$FC_LIGHT_GREEN$FC_BOLD" "	File: $origin/$af"
						coecho "$FC_LIGHT_GREEN$FC_BOLD" "	Linked to: ${PROFILE[SERVER_WORKER]}/mods/$m-$c""_$filenumber-$af"
						succesfullModsPakExtra=$(($succesfullModsPakExtra+1))
					else
						coecho "$FC_LIGHT_RED$FC_BOLD" "	could not link file $origin/$af"
						coecho "$FC_LIGHT_RED$FC_BOLD" "	Error: $err"
						failcountExtra=$(($failcountExtra+1))
					fi
					filenumber=$(($filenumber+1))
				done <<< "$fn"
				if [ "$err" != "" ]; then
					continue
				fi
				succesfullModsExtra=$(($succesfullModsExtra+1))
				c=$(($c+1))
			else
				coecho "$FC_LIGHT_RED$FC_BOLD" "Extra mod \"$(getModName $m)\" is missing"
				coecho "$FC_LIGHT_RED$FC_BOLD" "	ID: $m"
				coecho "$FC_LIGHT_RED$FC_BOLD" "	assumed dir path: $origin"
				coecho "$FC_LIGHT_RED$FC_BOLD" "	workshop link: https://steamcommunity.com/sharedfiles/filedetails/?id=$m"
				if [ ! -z "${RETRIED_MODS[$m]}" ]; then
					exit 1
				else
					coecho "$FC_LIGHT_YELLOW$FC_BOLD" "Will retry to download '$name'"
					local fcc
					while ! downloadMod $m; do
						fcc=$(($fcc+1))
						if [ $fcc -gt 5 ]; then
							coecho "$FC_BOLD$FC_RED" "Tried to download $(getModName $m) $(($fcc-1)) times, failed to update"
							exit 1
						fi
					done
					declare -p RETRIED_MODS 2>/dev/null >/dev/null || declare -gA RETRIED_MODS
					RETRIED_MODS[$m]=yes
					unlink
					linkMods
				fi

			fi

		done

		if [ $succesfullMods -gt 0 ]; then
			coecho "$FC_LIGHT_GREEN$FC_BOLD" "Successfully linked $succesfullMods mods!"
			coecho "$FC_LIGHT_GREEN$FC_BOLD" "Successfully linked $succesfullModsPak .pak files!"
		fi

		if [ $succesfullModsExtra -gt 0 ]; then
			coecho "$FC_LIGHT_GREEN$FC_BOLD" "Successfully linked $succesfullModsExtra Extra mods!"
			coecho "$FC_LIGHT_GREEN$FC_BOLD" "Successfully linked $succesfullModsPakExtra .pak files from Extra mods!"
		fi

		if [ $failcount -gt 0 ]; then
			coecho "$FC_LIGHT_RED$FC_BOLD" "Failed to link $failcount mods"
		fi

		if [ $failcountExtra -gt 0 ]; then
			coecho "$FC_LIGHT_RED$FC_BOLD" "Failed to link $failcountExtra Extra mods"
		fi
	fi
}

function unlinkMods {
	closeIfNotProfile
	coecho "$FC_LIGHT_YELLOW$FC_BOLD" "Mods removed!"
	rm -f ${PROFILE[SERVER_WORKER]}/mods/*
}

function updateMods {
	closeIfNotProfile
	if [ -z "$UPDATE" ]; then
		coecho "$FC_LIGHT_GREEN$FC_BOLD" "Mod update..."
	fi
	if [ "${PROFILE[STOP_COMMAND]}" == "" ]; then
		coecho "$FC_LIGHT_CYAN" "Please choose the stop command"
		coecho "$FC_LIGHT_CYAN" "1: $0 stop # Only for standalone installations"
		# coecho "$FC_LIGHT_CYAN" "2: sudo systemctl stop servicename # if you have setup this script as a system service"
		read r
		while [ "$r" != "1" ] && [ "$r" != "2" ]; do
			coecho "$FC_LIGHT_CYAN" "Please choose the stop command"
			coecho "$FC_LIGHT_CYAN" "1: $0 stop # Only for standalone installations"
			# coecho "$FC_LIGHT_CYAN" "2: sudo systemctl stop servicename # if you have setup this script as a system service"
			read r
		done
		if [ "$r" == "1" ]; then
			PROFILE[STOP_COMMAND]="\$0 stop"
			PROFILE[START_COMMAND]="\$0 start"
			saveVar PROFILE "$CONFIG_DIR/${ALIASMAP[$CURRENT_PROFILE]}"
		else
			coecho "$FC_LIGHT_CYAN" "Please enter the name of the service"
			read rr
			coecho "$FC_LIGHT_YELLOW" "sudo systemctl stop $rr"
			coecho "$FC_LIGHT_CYAN" "is that correct [Y/N]?"
			read r
			while [ "$(toLower "$r")" != "y" ]; do
				coecho "$FC_LIGHT_CYAN" "Please enter the name of the service"
				read rr
				coecho "$FC_LIGHT_YELLOW" "sudo systemctl stop $rr"
				coecho "$FC_LIGHT_CYAN" "is that correct [Y/N]?"
				read r
			done
			PROFILE[STOP_COMMAND]="sudo systemctl stop $rr"
			PROFILE[START_COMMAND]="sudo systemctl start $rr"
			saveVar PROFILE "$CONFIG_DIR/${ALIASMAP[$CURRENT_PROFILE]}"
			coecho "$FC_LIGHT_RED$FC_BOLD" "You need to add the following lines to /etc/sudoers:"
			coecho "$FC_LIGHT_RED$FC_BOLD" "$USERNAME	ALL=NOPASSWD:/usr/bin/systemctl start $rr"
			coecho "$FC_LIGHT_RED$FC_BOLD" "$USERNAME	ALL=NOPASSWD:/usr/bin/systemctl stop $rr"
			coecho "$FC_LIGHT_RED$FC_BOLD" "This is so the scritp's evironment has permission to restart the server when updating it"
			coecho "$FC_LIGHT_RED$FC_BOLD" "[ENTER] to continue"
			read r
		fi
	fi
	if [ ! -z "$(isScreen ${PROFILE[SCREEN_NAME]})" ]; then
		coecho "$FC_LIGHT_YELLOW" "Server is running"
		if [ "$STOP_ON_UPDATE" != "1" ]; then
			coecho "$FC_LIGHT_RED" "Can not update while the server is running"
			coecho "$FC_LIGHT_RED" "specify --restart or --stop to close it when running update"
			exit 1
		fi
	fi
	if [ "$STOP_ON_UPDATE" == "1" ] && [ -z "${PROFILE[STOP_COMMAND]}" ]; then
		coecho "$FC_LIGHT_RED$FC_BOLD" "--restart but stop command has not found"
		exit 1
	fi
	if [ ! -z "$(isScreen ${PROFILE[SCREEN_NAME]})" ] && [ "$STOP_ON_UPDATE" == "1" ] && [ ! -z "${PROFILE[STOP_COMMAND]}" ]; then
		coecho "$FC_LIGHT_CYAN$FC_BOLD" "Stopping server... ${PROFILE[STOP_COMMAND]}"
		eval "${PROFILE[STOP_COMMAND]}"
	fi
	UPDATED=1
	findSteam
	coecho "$FC_LIGHT_GREEN" "Preparing for steamcmd..."
	if [ ! -z "$REMOVE_WORKSHOP_CONTENTS" ]; then
		rm -r $STEAM/workshop/content/$APPID/*
	fi
	if ! loadMods; then
		[ -z "${PROFILE[ON_0_MODS]}" ] && coecho "$FC_RED$FCBOLD" "Variable ON_0_MODS must be set"

		case ${PROFILE[ON_0_MODS]} in

			skip)
				if [ "$START_ON_UPDATE" == "1" ] && [ -z "${PROFILE[START_COMMAND]}" ]; then
					coecho "$FC_LIGHT_RED$FC_BOLD" "--restart but stop command has not found"
					exit 1
				fi
				if [ "$START_ON_UPDATE" == "1" ]; then
					coecho "$FC_LIGHT_CYAN$FC_BOLD" "Starting server... ${PROFILE[START_COMMAND]}"
					eval "${PROFILE[START_COMMAND]}"
				fi
				return 0
			;;

			crash)
				exit 1
			;;

			*)
				coecho "$FC_RED$FCBOLD" "Variable ON_0_MODS improperly set (${PROFILE[ON_0_MODS]})"
				exit 1
			;;

		esac
	fi
	cmdline="+login anonymous"
	for c in $(seq 0 ${PARSED_MODPACK[~lastItem]}); do
		local id=${PARSED_MODPACK[$c~id]}
		local name=${PARSED_MODPACK[$c~name]}
		cmdline="$cmdline +workshop_download_item $APPID $id"
	done
	cmdline="$cmdline +quit"
	coecho "$FC_LIGHT_CYAN$FC_BOLD" "steamcmd commandline dump: $cmdline"
	coecho "$FC_LIGHT_CYAN$FC_BOLD" "dumping steamcmd output to: ${PROFILE[DUMP_FILES]}/dumps/latestSteamCMDdump.stdout"
	coecho "$FC_LIGHT_GREEN" "Running steamcmd, this might take a while depending on the modpack size..."
	mkdir -p "${PROFILE[DUMP_FILES]}/dumps"
	if [ "$DRY_RUN" == "1" ]; then
		coecho "$FC_LIGHT_YELLOW$FC_BOLD" "WARNING: Dry run, skipped steamcmd"
	else
		/usr/games/steamcmd $cmdline 2>&1 > "${PROFILE[DUMP_FILES]}/dumps/latestSteamCMDdump.stdout"
	fi
	coecho "$FC_LIGHT_GREEN" "Looking for errors in the steam dump"
	local good=0
	local errors=""
	for i in $(seq 1 3); do
		errors="$(cat ${PROFILE[DUMP_FILES]}/dumps/latestSteamCMDdump.stdout 2>/dev/null | grep -oE "\s+\.{3}ERROR\!.+downloading\s+item\s+[0-9]+" | grep -oE "[0-9]+$")"
		if [ "$errors" == "" ]; then
			good=1
			break
		fi
		local modnames=""
		cmdline="+login anonymous"
		for m in ${errors[@]}; do
			[ "$modnames" == "" ] && modnames="'${PARSED_MODPACK[$m~name]}'($m)" || modnames="$modnames, '${PARSED_MODPACK[$m~name]}'($m)"
			cmdline="$cmdline +workshop_download_item $APPID $m"
		done
		cmdline="$cmdline +quit"
		coecho "$FC_LIGHT_YELLOW$FC_BOLD" "Retrying failed downloads: $modnames"
		coecho "$FC_LIGHT_CYAN$FC_BOLD" "steamcmd commandline dump: $cmdline"
		coecho "$FC_LIGHT_CYAN$FC_BOLD" "dumping steamcmd output to: ${PROFILE[DUMP_FILES]}/dumps/latestSteamCMDdump.stdout"
		coecho "$FC_LIGHT_GREEN" "Running steamcmd, this might take a while depending on the modpack size..."
		if [ "$DRY_RUN" == "1" ]; then
			coecho "$FC_LIGHT_YELLOW$FC_BOLD" "WARNING: Dry run, skipped steamcmd"
		else
			/usr/games/steamcmd $cmdline 2>&1 > "${PROFILE[DUMP_FILES]}/dumps/latestSteamCMDdump.stdout"
		fi
	done

	if [ "$good" == 1 ]; then
		coecho "$FC_LIGHT_GREEN" "Update: All good ratty!"
	else
		coecho "$FC_LIGHT_YELLOW$FC_BOLD" "Oof I could not update some mods..."
		for m in ${errors[@]}; do
			coecho "$FC_LIGHT_YELLOW$FC_BOLD" "MOD: '${PARSED_MODPACK[$m~name]}'"
			coecho "$FC_LIGHT_YELLOW$FC_BOLD" "	ID: $m"
			coecho "$FC_LIGHT_YELLOW$FC_BOLD" "	Workshop Link: ${PARSED_MODPACK[$m~link]}"
			if [ -d $STEAM/workshop/content/$APPID/$m ]; then
				coecho "$FC_LIGHT_YELLOW$FC_BOLD" "	Location [Found]: $STEAM/workshop/content/$APPID/$m"
			else
				coecho "$FC_LIGHT_YELLOW$FC_BOLD" "	Location [Not Found]: $STEAM/workshop/content/$APPID/$m"
			fi
		done
	fi

	if [ ! -z "${EXTRA_MODS[0]}" ]; then

		coecho "$FC_YELLOW$FC_BOLD" "Updating Extra mods"
		coecho "$FC_LIGHT_GREEN" "Preparing for steamcmd..."
		
		cmdline="+login anonymous"

		for m in ${EXTRA_MODS[@]}; do
			cmdline="$cmdline +workshop_download_item $APPID $m"
		done
		cmdline="$cmdline +quit"

		coecho "$FC_LIGHT_CYAN$FC_BOLD" "steamcmd commandline dump: $cmdline"
		coecho "$FC_LIGHT_CYAN$FC_BOLD" "dumping steamcmd output to: ${PROFILE[DUMP_FILES]}/dumps/latestSteamCMDdump.stdout"
		coecho "$FC_LIGHT_GREEN" "Running steamcmd, this might take a while depending on the modpack size..."

		if [ "$DRY_RUN" == "1" ]; then
			coecho "$FC_LIGHT_YELLOW$FC_BOLD" "WARNING: Dry run, skipped steamcmd"
		else
			/usr/games/steamcmd $cmdline 2>&1 > "${PROFILE[DUMP_FILES]}/dumps/latestSteamCMDdump.stdout"
		fi

		for i in $(seq 1 3); do

			errors="$(cat ${PROFILE[DUMP_FILES]}/dumps/latestSteamCMDdump.stdout 2>/dev/null | grep -oE "\s+\.{3}ERROR\!.+downloading\s+item\s+[0-9]+" | grep -oE "[0-9]+$")"
			if [ "$errors" == "" ]; then
				good=1
				break
			fi
			coecho "$FC_LIGHT_GREEN" "Preparing for steamcmd..."
			
			cmdline="+login anonymous"

			for m in ${EXTRA_MODS[@]}; do
				cmdline="$cmdline +workshop_download_item $APPID $m"
			done
			cmdline="$cmdline +quit"

			coecho "$FC_LIGHT_CYAN$FC_BOLD" "steamcmd commandline dump: $cmdline"
			coecho "$FC_LIGHT_CYAN$FC_BOLD" "dumping steamcmd output to: ${PROFILE[DUMP_FILES]}/dumps/latestSteamCMDdump.stdout"
			coecho "$FC_LIGHT_GREEN" "Running steamcmd, this might take a while depending on the modpack size..."

			if [ "$DRY_RUN" == "1" ]; then
				coecho "$FC_LIGHT_YELLOW$FC_BOLD" "WARNING: Dry run, skipped steamcmd"
			else
				/usr/games/steamcmd $cmdline 2>&1 > "${PROFILE[DUMP_FILES]}/dumps/latestSteamCMDdump.stdout"
			fi

		done
	fi

	if [ "$good" == 1 ]; then
		coecho "$FC_LIGHT_GREEN" "Update: All good ratty!"
	else
		coecho "$FC_LIGHT_YELLOW$FC_BOLD" "Oof I could not update some mods..."
		for m in ${errors[@]}; do
			coecho "$FC_LIGHT_YELLOW$FC_BOLD" "MOD: '${PARSED_MODPACK[$m~name]}'"
			coecho "$FC_LIGHT_YELLOW$FC_BOLD" "	ID: $m"
			coecho "$FC_LIGHT_YELLOW$FC_BOLD" "	Workshop Link: ${PARSED_MODPACK[$m~link]}"
			if [ -d $STEAM/workshop/content/$APPID/$m ]; then
				coecho "$FC_LIGHT_YELLOW$FC_BOLD" "	Location [Found]: $STEAM/workshop/content/$APPID/$m"
			else
				coecho "$FC_LIGHT_YELLOW$FC_BOLD" "	Location [Not Found]: $STEAM/workshop/content/$APPID/$m"
			fi
		done
	fi

	relink

	if [ "$START_ON_UPDATE" == "1" ] && [ -z "${PROFILE[START_COMMAND]}" ]; then
		coecho "$FC_LIGHT_RED$FC_BOLD" "--restart but stop command has not found"
		exit 1
	fi
	if [ "$START_ON_UPDATE" == "1" ]; then
		coecho "$FC_LIGHT_CYAN$FC_BOLD" "Starting server... ${PROFILE[START_COMMAND]}"
		eval "${PROFILE[START_COMMAND]}"
	fi
}

function start {
	closeIfNotProfile
	# testFunc
	# #remove me after testing
	# return 0
	if [ -z "$INVOCATION_ID" ]; then
		if [ "${PROFILE[SERVICE_HANDLER]}" == "systemctl" ]; then
			eval "${PROFILE[START_COMMAND]}"
			coecho "\e[32m" "Server Start"
			exit 0
		fi
	fi
	
	if [ ! -z $(isScreen ${PROFILE[SCREEN_NAME]}) ]; then
		coecho "\e[32m" "Already Running"
		exit 0
	fi

	coecho "\e[32m" "Server Start"
	#start a demonized screen
	screen -dmS ${PROFILE[SCREEN_NAME]}
	#load bash profile to get env variables
	# screen -S   ${PROFILE[SCREEN_NAME]} -p 0 -X stuff "source $VAR_SCRIPT^M"
	#go into the working directory
	screen -S   ${PROFILE[SCREEN_NAME]} -p 0 -X stuff "cd ${PROFILE[EXECUTABLE_DIR]}^M"
	#run the server boot script and concatenate an exit command to close the screen on server exit
	screen -S   ${PROFILE[SCREEN_NAME]} -p 0 -X stuff "${PROFILE[RUN_SCRIPT]} ; exit^M"
}

function demonize {
	closeIfNotProfile
	#call the start sequence
	if [ -z "$INVOCATION_ID" ]; then
		if [ "${PROFILE[SERVICE_HANDLER]}" == "systemctl" ]; then
			eval "${PROFILE[START_COMMAND]}"
		fi
	else
		start
	fi
	
	if [ -z "$INVOCATION_ID" ] && [ "$SERVICE_HANDLER" == "your-awesm" ]; then
		echo "$$" > "${PROFILE[PROFILE_DIR]}/demonized.pid"
	fi
	#check if the server is still up every minute so the script keeps hold of the prompt
	#and systemd doesn't think is crashed, also will exit on server exit so systemd restarts
	#the server
	while [ ! -z "$(isScreen ${PROFILE[SCREEN_NAME]})" ]; do
		sleep ${PROFILE[SLEEP]}
	done
	[ ! -z "$INVOCATION_ID" ] && rm "${PROFILE[PROFILE_DIR]}/demonized.pid"
}

function stop {
	if [ -z "$INVOCATION_ID" ]; then
		if [ "${PROFILE[SERVICE_HANDLER]}" == "systemctl" ]; then
			eval "${PROFILE[STOP_COMMAND]}"
			coecho "\e[32m" "Server Stop"
			exit 0
		fi
	fi

	if [ -z "$(isScreen ${PROFILE[SCREEN_NAME]})" ]; then
		coecho "\e[32m" "Server isn't running"
		exit 0
	fi

	coecho "\e[32m" "Server Stop"
	#send stop signial to the server, send a previous enter signial in case there was something on the console (^M)
	screen -S   ${PROFILE[SCREEN_NAME]} -p 0 -X stuff "^C"

	#record when the stop request was issued
	start=$(date "+%s")

	#wait while checking if it closed, if timeout is reached stop waiting
	while [ ! -z "$(isScreen ${PROFILE[SCREEN_NAME]})" ] && [ $(( $(date "+%s") - $start )) -lt ${PROFILE[TIMEOUT]} ]; do
		sleep 1s
	done

	#if timeout was reached kill the server
	if [ $(( $(date "+%s") - $start )) -ge ${PROFILE[TIMEOUT]} ]; then
		coecho "\e[1m\e[31m" "screen still active after ${PROFILE[TIMEOUT]} seconds, killing it"
		screen -X -S "$(isScreen ${PROFILE[SCREEN_NAME]})" kill
		exit 1
	fi
}

function update {
	updateMods
}

function relink {
	unlinkMods
	linkMods
	cleanup
}

function reset_universe {
	${PROFILE[STOP_COMMAND]}
	prev="$(pwd)"
	cd "${PROFILE[SERVER_WORKER]}/storage"
	[ ! -e universe ] && exit 0
	i=0
	while [ -e "universe-$i" ]; do i=$(($i+1)); done
	mv universe universe-$i/
	cd "$prev"
}

function hook_log {
	cat "${PROFILE[SERVER_WORKER]}/storage/starbound_server.log"
	echo "******************************************************"
	echo "                       *******                        "
	tail -f "${PROFILE[SERVER_WORKER]}/storage/starbound_server.log"
}

function get_last_log {
	cp "${PROFILE[SERVER_WORKER]}/storage/starbound_server.log" .
}

function get_all_logs {
	cp "${PROFILE[SERVER_WORKER]}/storage/starbound_server.log*" .
}

function config {
	nano "${PROFILE[SERVER_WORKER]}/storage/starbound_server.config"
}

function unlink {
	unlinkMods
}

function declareProfile {
	! isAssoc PROFILE && declare -Ag PROFILE
}

function heavilySanitize {
	local prev="$(sed -E "s/\s+/_/g" <<< $1 | grep -oE "([0-9a-zA-Z]|-|_)+")"
	local out=""
	for x in ${prev[@]}; do
		out="$out$x"
	done
	echo "$out"
}

function showStarboundDir {
	coecho "$FC_GREEN$FC_BOLD" "${PROFILE[SERVER_WORKER]}"
}

function renameAssocArray {
	unset $2
	eval "$(declare -p $1 | sed -E "s/^declare -/declare -g -/g" | sed -E "s/declare -g -A [A-Za-z0-9]+=/declare -g -A $2=/g")"
	unset $1
}

function reloadAliasMap {
	unset ALIASMAP
	eval "$(loadVar ALIASMAP "$CONFIG_DIR")"
	# echo reloaded 
	# declare -p ALIASMAP
	if [ ${#ALIASMAP[@]} -eq 0 ]; then
		unset ALIASMAP
		declare -Ag ALIASMAP
	fi
}

function saveProfile {
	saveVar PROFILE "${PROFILE[PROFILE]}" "true"
}

function saveCurrentProfile {
	saveVar CURRENT_PROFILE "$CONFIG_DIR" "true"
}

function saveAliasMap {
	saveVar ALIASMAP "$CONFIG_DIR" "true"
}

function removeAlias {
	unset ALIASMAP[$1]
	saveAliasMap
}

function loadProfile {
	reloadAliasMap
	eval "$(loadVar PROFILE "$CONFIG_DIR/${ALIASMAP[$CURRENT_PROFILE]}")"
}

function removeAllAliases {
	coecho "$FC_BOLD$FC_LIGHT_GREEN" "Removing all aliases for $FC_LIGHT_CYAN$1"
	for x in ${!ALIASMAP[@]}; do
		if [ "${ALIASMAP[$x]}" == "$1" ]; then
			unset ALIASMAP[$x]
		fi
	done
	saveAliasMap
}

function isScreenNameInUse {
	#store PROFILE on a different variable in case it's needed
	renameAssocArray PROFILE temporary

	local targetScreenName="$1"

	for x in ${ALIASMAP[@]}; do
		unset PROFILE
		eval "$(loadVar PROFILE "$CONFIG_DIR/$x")"
		if [ "${PROFILE[SCREEN_NAME]}" == "$targetScreenName" ]; then
			declare -g -- CONFLICT="$x"
			renameAssocArray temporary PROFILE
			return 0
		fi
	done
	
	#restore profile after we're done
	renameAssocArray temporary PROFILE
	return 1
}

function rmProfile {
	local opt=""
	if ! isYes "$FORCE"; then
		coecho "$FC_BOLD$FC_LIGHT_YELLOW" "Deleting $FC_LIGHT_CYAN$CURRENT_PROFILE$FC_LIGHT_YELLOW are you sure?"
		echo -n "[YES/NO]: "
		read -r opt
	else
		opt="yes"
	fi
	if isYes "$opt"; then
		coecho "$FC_BOLD$FC_LIGHT_GREEN" "Deleteing the profile: $FC_LIGHT_CYAN$CURRENT_PROFILE"

		loadProfile
		# declare -p ALIASMAP
		
		local dir="${PROFILE[SERVER_WORKER]}/assets"
		if [ ! -z "$(file "$dir" | grep -o "symbolic link")" ]; then
			[ -e "$dir" ] && rm "$dir"
		else
			[ -e "$dir" ] && rm -r "$dir"
		fi
		dir="${PROFILE[SERVER_WORKER]}/doc"
		if [ ! -z "$(file "$dir" | grep -o "symbolic link")" ]; then
			[ -e "$dir" ] && rm "$dir"
		else
			[ -e "$dir" ] && rm -r "$dir"
		fi
		dir="${PROFILE[SERVER_WORKER]}/tiled"
		if [ ! -z "$(file "$dir" | grep -o "symbolic link")" ]; then
			[ -e "$dir" ] && rm "$dir"
		else
			[ -e "$dir" ] && rm -r "$dir"
		fi
		rm -r "${PROFILE[PROFILE]}"
		rm -r "${PROFILE[SERVER_WORKER]}"
		removeAllAliases "$CURRENT_PROFILE"
		reloadAliasMap
		CURRENT_PROFILE=""
		for x in ${ALIASMAP[@]}; do
			CURRENT_PROFILE="$x"
			break
		done
		saveCurrentProfile
	fi
}

function createProfile {
	if [ -z "$CURRENT_PROFILE" ]; then
		coecho "$FC_BOLD$FC_LIGHT_YELLOW" "Profile name must be set with $FC_LIGHT_CYAN""-s <profile name> $FC_LIGHT_CYAN""or$FC_LIGHT_GREEN --name <profile name>"
		return 1
	fi
	if findSteam; then
		! isAssoc PROFILE && declare -Ag PROFILE
		[ -z "${PROFILE[ON_0_MODS]}" ] && PROFILE[ON_0_MODS]="skip"
		[ -z "${PROFILE[TIMEOUT]}" ] && PROFILE[TIMEOUT]="30"
		[ -z "${PROFILE[SLEEP]}" ] && PROFILE[SLEEP]="60"
		[ -z "${PROFILE[SCREEN_NAME]}" ] && PROFILE[SCREEN_NAME]="$CURRENT_PROFILE"
		[ -z "${PROFILE[PROFILE]}" ] && PROFILE[PROFILE]="$CONFIG_DIR/$CURRENT_PROFILE"
		[ -z "${PROFILE[PROFILE_DIR]}" ] && PROFILE[PROFILE_DIR]="$SERVER_WORKERS/$CURRENT_PROFILE"
		[ -z "${PROFILE[SERVER_WORKER]}" ] && PROFILE[SERVER_WORKER]="$SERVER_WORKERS/$CURRENT_PROFILE/Starbound_Server"
		[ -z "${PROFILE[EXECUTABLE_DIR]}" ] && PROFILE[EXECUTABLE_DIR]="$SERVER_WORKERS/$CURRENT_PROFILE/Starbound_Server/linux"
		[ -z "${PROFILE[DUMP_FILES]}" ] && PROFILE[DUMP_FILES]="$SERVER_WORKERS/$CURRENT_PROFILE/DUMP"
		[ -z "${PROFILE[LOGFILES]}" ] && PROFILE[LOGFILES]="$SERVER_WORKERS/$CURRENT_PROFILE/logs"
		[ -z "${PROFILE[LOGPARSE]}" ] && PROFILE[LOGPARSE]="yes"
		[ -z "${PROFILE[RUN_SCRIPT]}" ] && PROFILE[RUN_SCRIPT]="./starbound_server"
		[ -z "${PROFILE[COPY]}" ] && PROFILE[COPY]="0"
		[ -z "${PROFILE[EASY_ACCESS]}" ] && PROFILE[EASY_ACCESS]="yes"
		[ -z "${PROFILE[SELF_LOGGING]}" ] && PROFILE[SELF_LOGGING]="yes"
		[ -z "${PROFILE[LOG_BACKUP]}" ] && PROFILE[LOG_BACKUP]="yes"
		[ -z "${PROFILE[SERVICE_HANDLER]}" ] && PROFILE[SERVICE_HANDLER]="your-awesm"
		reloadAliasMap
		[ -z "${ALIASMAP[$CURRENT_PROFILE]}" ] && ALIASMAP[$CURRENT_PROFILE]="$CURRENT_PROFILE"
		PROFILE[SCREEN_NAME]="$(heavilySanitize "${PROFILE[SCREEN_NAME]}")"
		if isScreenNameInUse "${PROFILE[SCREEN_NAME]}"; then
			coecho "$FC_BOLD$FC_YELLOW" "there can't be two servers with the same screen name, conflict source: $FC_CYAN$CONFLICT$FC_LIGHT_YELLOW you can specify a name with $FC_LIGHT_CYAN--screen-name \"<screen name>\""
			return 1
		fi
		# declare -p PROFILE
		mkdir -p "${PROFILE[SERVER_WORKER]}"
		linkify "$STEAM/common/Starbound/assets/" "${PROFILE[SERVER_WORKER]}/assets"
		linkify "$STEAM/common/Starbound/doc/" "${PROFILE[SERVER_WORKER]}/doc"
		linkify "$STEAM/common/Starbound/tiled/" "${PROFILE[SERVER_WORKER]}/tiled"
		mkdir -p "${PROFILE[SERVER_WORKER]}/linux"
		linkify "$STEAM/common/Starbound/linux/libsteam_api.so" "${PROFILE[SERVER_WORKER]}/linux/libsteam_api.so"
		linkify "$STEAM/common/Starbound/linux/sbinit.config" "${PROFILE[SERVER_WORKER]}/linux/sbinit.config"
		linkify "$STEAM/common/Starbound/linux/starbound_server" "${PROFILE[SERVER_WORKER]}/linux/starbound_server"
		linkify "$STEAM/common/Starbound/linux/make_versioned_json" "${PROFILE[SERVER_WORKER]}/linux/make_versioned_json"
		mkdir -p "${PROFILE[SERVER_WORKER]}/mods"
		saveCurrentProfile
		saveAliasMap
		saveProfile
	fi
}

function collectServerList {
	reloadAliasMap
	declare -ag SERVER_LIST=()
	for x in ${ALIASMAP[@]}; do
		if ! isInArray "$(declare -p SERVER_LIST)" "$x"; then
			SERVER_LIST[${#SERVER_LIST[@]}]="$x"
		fi
	done
}

function listProfiles {
	collectServerList
	for x in ${SERVER_LIST[@]}; do
		CURRENT_PROFILE="$x"
		loadProfile
		coecho "$FC_BOLD$FC_LIGHT_GREEN" "$x"
		coecho "$FC_BOLD$FC_LIGHT_GREEN" "	Starbound:	${PROFILE[SERVER_WORKER]}"
		coecho "$FC_BOLD$FC_LIGHT_GREEN" "	Screen:		${PROFILE[SCREEN_NAME]}"
	done
}

function listThings {
	unset ACTION

	while [ $# -gt 0 ]; do
		
		case $1 in

			profiles)
				ACTION="listProfiles"
			;;

			*)
				coecho "$FC_BOLD" "$FC_LIGHT_YELLOW""I don't know what: ""$FC_LIGHT_CYAN$1$FC_LIGHT_YELLOW is, can't list it bruh"
				exit 1
			;;

		esac

		shift
	done

	eval "$ACTION"
}

function profile {
	unset ACTION
	declare -A definedSingularOptions
	while [ $# -gt 0 ]; do
		
		case $1 in

			current)
				coecho "$FC_BOLD$FC_GREEN" "$CURRENT_PROFILE"
				exit 0
			;;

			set)
				pop="$1"
				shift
				if [ "$1" != "" ] && [ "$#" -gt 0 ]; then
					reloadAliasMap
					if [ -z "${ALIASMAP[$1]}" ]; then
						coecho "$FC_BOLD$FC_YELLOW" "'$FC_LIGHT_CYAN$1$FC_YELLOW' is not a valid server profile, please use: $FC_LIGHT_CYAN$MYSELF profile create \"$1\""
						exit 1
					else
						declare -g -- CURRENT_PROFILE="$1"
						saveCurrentProfile
					fi
				else
					coecho "$FC_BOLD$FC_YELLOW" "Expected server profile name or alias after $FC_LIGHT_CYAN$pop"
					exit 1
				fi
				unset pop
			;;

			list)
				ACTION="listThings profiles"
			;;
			
			create)
				unset PROFILE
				local opt="$1"
				if [ ! -z "${definedSingularOptions[create]}" ]; then
					coecho "$FC_BOLD$FC_LIGHT_CYAN" "$opt$FC_LIGHT_YELLOW can only defined once"
					exit 1
				fi
				definedSingularOptions[create]=yes
				shift
				if [ "$1" != "" ] && [ "$#" -gt 0 ]; then
					CURRENT_PROFILE="$1"
				else
					coecho "$FC_BOLD$FC_LIGHT_YELLOW" "Expected name after $FC_LIGHT_CYAN$opt"
				fi
				ACTION="createProfile"
			;;

			delete)
				ACTION="rmProfile"
			;;

			--screen-name)
				local opt="$1"
				if [ ! -z "${PROFILE[SCREEN_NAME]}" ]; then
					coecho "$FC_BOLD$FC_LIGHT_CYAN" "$opt$FC_LIGHT_YELLOW can only defined once"
					exit 1
				fi
				shift
				if [ "$1" != "" ] && [ "$#" -gt 0 ]; then
					declareProfile
					PROFILE[SCREEN_NAME]="$1"
				else
					coecho "$FC_BOLD$FC_LIGHT_YELLOW" "Expected screen name after $FC_LIGHT_CYAN$opt"
				fi
			;;

			--force)
				FORCE="yes"
			;;

			*)
				coecho "$FC_BOLD" "$FC_LIGHT_CYAN$1$FC_LIGHT_YELLOW unrecognized option for profile"
				exit 1
			;;

		esac

		shift
	done

	unset definedSingularOptions
	eval "$ACTION"
}

function printCopyright {
	coecho "$FC_BOLD$FC_LIGHT_GREEN" "YOUR AWEsome Starbound Manager - $FC_LIGHT_CYAN""your-awesm$FC_LIGHT_GREEN Â© $FC_LIGHT_PINK""Reiikz$FC_LIGHT_GREEN - $COPYRIGHT_YEAR"
	coecho "$FC_BOLD" "$FC_LIGHT_CYAN$MYSELF$FC_LIGHT_GREEN command - v $FC_LIGHT_CYAN$VERSION$FC_LIGHT_GREEN - MIT LICENSED"
	coecho "$FC_BOLD$FC_LIGHT_GREEN" "Official source: $FC_BLUE$SOURCE_URL"
	coecho "$FC_BOLD$FC_LIGHT_GREEN" "Report bugs to: $FC_BLUE$ERROR_REPORTING_TO"
	coecho "$FC_BOLD$FC_LIGHT_GREEN" "For documentation refer to: $FC_BLUE$DOCUMENTATION"
}

while [ $# -gt 0 ]; do

	case $1 in

		demonize)
			[ ! -z "$ACTION" ] && coecho "$FC_LIGHT_YELLOW$FC_BOLD" "Ambiguous situation action is $ACTION but specified $1" && exit 1
			ACTION="demonize"
		;;

		start)
			[ ! -z "$ACTION" ] && coecho "$FC_LIGHT_YELLOW$FC_BOLD" "Ambiguous situation action is $ACTION but specified $1" && exit 1
			ACTION="start"
		;;

		stop)
			[ ! -z "$ACTION" ] && coecho "$FC_LIGHT_YELLOW$FC_BOLD" "Ambiguous situation action is $ACTION but specified $1" && exit 1
			ACTION="stop"
		;;

		update)
			[ ! -z "$ACTION" ] && coecho "$FC_LIGHT_YELLOW$FC_BOLD" "Ambiguous situation action is $ACTION but specified $1" && exit 1
			shift
			if [ "$1" != "" ] && [ "$#" -gt 0 ]; then
				MODPACK="$1"
			else
				coecho "$FC_BOLD$FC_LIGHT_YELLOW" "Expected modpack url after $FC_LIGHT_CYAN""relink"
			fi
			ACTION="update"
		;;

		unlink)
			[ ! -z "$ACTION" ] && coecho "$FC_LIGHT_YELLOW$FC_BOLD" "Ambiguous situation action is $ACTION but specified $1" && exit 1
			ACTION="unlink"
		;;

		relink)
			[ ! -z "$ACTION" ] && coecho "$FC_LIGHT_YELLOW$FC_BOLD" "Ambiguous situation action is $ACTION but specified $1" && exit 1
			shift
			if [ "$1" != "" ] && [ "$#" -gt 0 ]; then
				MODPACK="$1"
			else
				coecho "$FC_BOLD$FC_LIGHT_YELLOW" "Expected modpack url after $FC_LIGHT_CYAN""relink"
			fi
			ACTION="relink"
		;;

		reset-universe)
			[ ! -z "$ACTION" ] && coecho "$FC_LIGHT_YELLOW$FC_BOLD" "Ambiguous situation action is $ACTION but specified $1" && exit 1
			ACTION="reset_universe"
		;;

		hook-log)
			[ ! -z "$ACTION" ] && coecho "$FC_LIGHT_YELLOW$FC_BOLD" "Ambiguous situation action is $ACTION but specified $1" && exit 1
			ACTION="hook_log"
		;;

		get-last-log)
			[ ! -z "$ACTION" ] && coecho "$FC_LIGHT_YELLOW$FC_BOLD" "Ambiguous situation action is $ACTION but specified $1" && exit 1
			ACTION="get_last_log"
		;;

		get-all-logs)
			[ ! -z "$ACTION" ] && coecho "$FC_LIGHT_YELLOW$FC_BOLD" "Ambiguous situation action is $ACTION but specified $1" && exit 1
			ACTION="get_all_logs"
		;;

		config)
			[ ! -z "$ACTION" ] && coecho "$FC_LIGHT_YELLOW$FC_BOLD" "Ambiguous situation action is $ACTION but specified $1" && exit 1
			ACTION="config"
		;;

		sbdir)
			[ ! -z "$ACTION" ] && coecho "$FC_LIGHT_YELLOW$FC_BOLD" "Ambiguous situation action is $ACTION but specified $1" && exit 1
			ACTION="showStarboundDir"
		;;

		--boring)
			COLORFUL=0
		;;

		--delete-workshop)
			REMOVE_WORKSHOP_CONTENTS=1
		;;

		--start)
			START_ON_UPDATE="1"
		;;

		--stop)
			STOP_ON_UPDATE="1"
		;;

		--restart)
			START_ON_UPDATE="1"
			STOP_ON_UPDATE="1"
		;;

		--dry-run)
			DRY_RUN="1"
		;;

		--cp)
			COPY="1"
		;;

		--mod)
			if [ -z "${EXTRA_MODS[@]}" ]; then
				declare -gA EXTRA_MODS
			fi
			shift
			mod="$(grep -oE "[0-9]+" <<< $1)"
			[ "$mod" == "" ] && coecho "$FC_RED" "expected numeric id after --mod" && exit 1
			EXTRA_MODS[${#EXTRA_MODS[@]}]="$mod"
			unset mod
		;;

		-s|--server|--profile|--server-profile|--profile-server)
			pop="$1"
			shift
			if [ "$1" != "" ] && [ "$#" -gt 0 ]; then
				reloadAliasMap
				if [ -z "${ALIASMAP[$1]}" ]; then
					coecho "$FC_BOLD$FC_YELLOW" "'$FC_LIGHT_CYAN$1$FC_YELLOW' is not a valid server profile, please use: $FC_LIGHT_CYAN$MYSELF profile create \"$1\""
					exit 1
				else
					declare -g -- CURRENT_PROFILE="$1"
					saveCurrentProfile
				fi
			else
				coecho "$FC_BOLD$FC_YELLOW" "Expected server profile name or alias after $FC_LIGHT_CYAN$pop"
				exit 1
			fi
			unset pop
		;;

		-h|--help|--h)
			ACTION="printOptions"
		;;

		profile)
			ACTION="profile"
			while [ $# -gt 0 ]; do
				shift
				[ $# -gt 0 ] && ACTION="$ACTION \"$1\""
			done
		;;

		list)
			ACTION="listThings"
			while [ $# -gt 0 ]; do
				shift
				[ $# -gt 0 ] && ACTION="$ACTION \"$1\""
			done
		;;

		--screen-name)
			coecho "$FC_BOLD$FC_LIGHT_CYAN" "$1 $FC_YELLOW""doesn't make sense in the current context"
			exit 1
		;;

		--force)
			FORCE="yes"
		;;

		--version|-v)
			ACTION="printCopyright"
		;;

		*)
			coecho "$FC_BOLD$FC_LIGHT_CYAN" "$1$FC_LIGHT_YELLOW unrecognized option"
			exit 1
		;;
	esac
	
	shift

done

##### Preload profile, this has to be implemented here to allow the functions to be loaded but this code to
##### be ran before the actual execution of whatever commands have been passed

[ -z "$CURRENT_PROFILE" ] && eval "$(loadVar CURRENT_PROFILE "$CONFIG_DIR")"
eval "$(loadVar ALIASMAP "$CONFIG_DIR")"
[ ! -z "$CURRENT_PROFILE" ] && [ ! -z "${ALIASMAP[$CURRENT_PROFILE]}" ] && eval "$(loadVar PROFILE "$CONFIG_DIR/${ALIASMAP[$CURRENT_PROFILE]}")"

#do not run if no action specified
if [ -z "$ACTION" ] && [ "$CURRENT_PROFILE" != "" ]; then
	if [ "$(isScreen "${PROFILE[SCREEN_NAME]}")" == "" ]; then
		coecho "$FC_LIGHT_CYAN$FC_BOLD" "Server is not running"
	else
		coecho "$FC_LIGHT_CYAN$FC_BOLD" "Server is running"
	fi
fi

eval "$ACTION"

